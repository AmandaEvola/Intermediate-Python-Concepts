import threading

# Function to increment a global variable
def increment(): 
    global counter 
    for _ in range(1000000):
        counter += 1

counter = 0
threads = []

# Create multiple threads
for _ in range(10):
    thread = threading.Thread(target=increment)
    threads.append(thread)
    thread.start()


# Wait for all threads to finish
for thread in threads:
    thread.join()

print("Counter:", counter)

# The Global Interpreter Lock (GIL) is a mutex that protects access to Python objects, preventing multiple native threads from executing Python bytecodes at once. This means that despite having multiple threads, only one thread can execute Python bytecode at a time, effectively serializing the execution of threads. The GIL impacts multithreading in Python and can affect the performance of multi-threaded Python programs, particularly those that are CPU-bound.
# Due to the GIL, the counter might not be incremented by exactly 10,000,000 as expected, and the program might not fully utilize all available CPU cores efficiently.


# A global variable in Python is a variable that is defined outside of any function or class definition and can be accessed from anywhere within the program, including inside functions and classes. When you declare a variable at the outermost scope of a Python program or module, it becomes a global variable.

# Bytecode in Python refers to the intermediate representation of a Python program that is generated by the Python interpreter when you run your code. Python code is compiled into bytecode, which is then executed by the Python virtual machine (PVM). The bytecode is platform-independent and is stored in .pyc files (compiled Python files) for future use, which allows Python programs to run more efficiently by avoiding recompilation of the source code each time it is executed.

# Bytecode is an abstraction layer between the high-level Python code and the low-level machine code executed by the computer's hardware. It enables Python to be a portable and dynamically typed language while still providing performance benefits through compilation.


# You can view the bytecode of a Python function using the dis module, which disassembles Python bytecode into a human-readable form. Here's an example:

import dis

def add(a, b):
    return a + b

dis.dis(add)